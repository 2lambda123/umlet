options {
  static              = false;
  IGNORE_CASE         = false;
  JAVA_UNICODE_ESCAPE = true;
  JDK_VERSION        = "1.6";
  // Not yet detected as a valid option by the Eclipse plugin, but works nonetheless. This is essential for GWT compatible generated code.
  JAVA_TEMPLATE_TYPE = "modern";  
}


PARSER_BEGIN(SequenceAllInOneParser)
package com.baselet.element.facet.specific.sequence_aio.gen;

import org.apache.log4j.Logger;

import com.baselet.control.enums.LineType;
import com.baselet.element.facet.specific.sequence_aio.Lifeline;
import com.baselet.element.facet.specific.sequence_aio.Message.ArrowType;
import com.baselet.element.facet.specific.sequence_aio.SequenceDiagram;
import com.baselet.element.facet.specific.sequence_aio.SequenceDiagramBuilder;
import com.baselet.element.facet.specific.sequence_aio.SequenceDiagramException;

public class SequenceAllInOneParser {
	private static final Logger log = Logger.getLogger(SequenceAllInOneParser.class);

	private boolean autoTick;
	
	/**
	 * Small data container to pass all informations.
	 */
	private class MessageArrowInfo {
		int duration = 0;
		boolean fromLeftToRight;
		LineType lineType;
		ArrowType arrowType;
	}

	private class InteractionConstraint {
		private String lifelineId = null;
		private String text = "";	}

	private class LifelineInterval {
		private String startId;
		private String endId;
	}
}
PARSER_END(SequenceAllInOneParser)

/* defines input to be ignored */
< * > SKIP:
{
	" "
	| "\t"
}

< DEFAULT, DIAGRAM_DEF > SKIP:
{
	"\n" : DEFAULT
	| "\r\n" : DEFAULT
	| "\r" : DEFAULT
}

< * > SKIP :
{
	<"//"(~["\n","\r"])*("\n"|"\r"|"\r\n")>
}

< DEFAULT > TOKEN:
{	< DIAGRAM_OPTION_OVERRIDE_ID :"overrideIds=" >
	| < DIAGRAM_OPTION_AUTO_TICK: "autoTick=" >
}

< DEFAULT > TOKEN :
{

	< DIAGRAM_TITLE: "title=" > : DIAGRAM_DEF
	| < LIFELINE_DEFINITIONS: "obj=" > : LIFELINE_DEF
	| < DIAGRAM_SEQUENCE :"sequence=" > : DIAGRAM_SEQ
}

< DIAGRAM_DEF > TOKEN:
{
	< DIAGRAM_TITLE_TEXT: (~ ["\r","\n"])+> : DEFAULT
}

/*< DIAGRAM_DEF > SKIP :
{
	<DIA_DEF_NL_DEF :> : DEFAULT
}*/


/*< DIAGRAM_OPTION > TOKEN :
{
}*/

< LIFELINE_DEF > TOKEN :
{
	< LL_DEF_NEW_LINE: "\n" | "\r\n" | "\r" > : DEFAULT
	| < LIFELINE_DEF_DELIMITER: "|" >
	/*| < LIFELINE_TITLE_DELIMITER: "~" > integrated in the title */
	| < LIFELINE_ACTOR: "ACTOR" >
	| < LIFELINE_ACTIVE: "ACTIVE" >
	| < LIFELINE_CREATED_LATER :"CREATED_LATER" >
	| < LIFELINE_TITLE: /* since | and ~ are special characters which delimit the title they need to be escaped */
		( 
			~["~","\\","\n","\r","|"] 
			| ("\\" ["\\","~","|"])
		)+
		"~" >
}

< DIAGRAM_SEQ > TOKEN :
{
	< TEXT_DELIMITER: ":" > : DIAGRAM_SEQ_TEXT
	| < LIST_DELIMITER: "," >
	| < OPEN_CURLY_BRACKET: "{" >
	| < CLOSE_CURLY_BRACKET: "}" >
	| < COMMAND_DELIMITER: ";" >
	| < MESSAGE_SOLID_LINE: "-" >
	| < MESSAGE_DASHED_LINE: "." >
	| < MESSAGE_ARROW_LEFT_OPEN: "<" >
	| < MESSAGE_ARROW_LEFT_FILLED: "<<<" >
	| < MESSAGE_ARROW_RIGHT_OPEN: ">" >
	| < MESSAGE_ARROW_RIGHT_FILLED: ">>>" >
	| < LOST: "lost" >
	| < FOUND: "found" >
	| < START_COREGION: "coregionStart=" >
	| < END_COREGION: "coregionEnd=" >
	| < INVARIANT: "invariant=" >
	| < STATE_INVARIANT: "stateInvariant=" >
	| < EXEC_SPEC_START: "on=" >
	| < EXEC_SPEC_END: "off=" >
	| < REF: "ref=" >
	| < CONTINUATION: "continuation=" >
	| < TICK: "tick=" >
	| < COMBINED_FRAGMENT: "combinedFragment=" >
	| < INTERACTION_CONSTRAINT: "constraint=" >
	| < UNSIGNED_INT_CONSTANT: ( ["0" - "9"] ) + >	| < SEQ_NEW_LINE: "\n" | "\r\n" | "\r" >
}

< LIFELINE_DEF, DIAGRAM_SEQ > TOKEN :
{
	< LIFELINE_ID: ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9"])* >
}

< DIAGRAM_SEQ_TEXT > TOKEN :
{
	< TEXT_UNTIL_NEXT_COMMAND : ( 
			~["\\","\n","\r",";"] 
			| ("\\" ["\\",";"])
		)+ > : DIAGRAM_SEQ
}

TOKEN :
{
	< UNSIGNED_DOUBLE_CONSTANT: ( <DIGIT> ) + ( "." (<DIGIT>)+ )? >
	| < #DIGIT: ["0" - "9"] >
	| < TRUE: "true" >
	| < FALSE: "false" >
}

/* general Tokens */
< * > TOKEN :
{
	<LAST_LINE_COMMENT: "//"(~["\n","\r"])*>
}

/* more general Tokens with no case distinction */
/*TOKEN [IGNORE_CASE] :
{
	< #HEX: ["0" - "9","a"-"f"] >
	| <  SIMPLE_STRING : "\""
   ( 
	   ( ~["\"","\\","\n","\r"]) // everything except the specified chars
	   | ("\\" ["\\","\""])
   )*
   "\"" >
}*/

/**
 * The main function which parses the whole diagram.
 * Line comments are skipped (see Tokens)
 */
SequenceDiagramBuilder start() :
{
	String titleText = null;
	SequenceDiagramBuilder diagram  = new SequenceDiagramBuilder();
	autoTick = true;
}
{
	(
		(
			titleText=DiagramTitle() { diagram.setTitle(titleText); }
			| Options(diagram)
			| LifelineDefinitions(diagram)
		)+
		< DIAGRAM_SEQUENCE > Sequence(diagram)
	)
	
	(< LAST_LINE_COMMENT >)?
	<EOF>
	{
		return diagram;
	}
}

String DiagramTitle() :
{
	String text = "";
}
{
	< DIAGRAM_TITLE >
	(
		< DIAGRAM_TITLE_TEXT > { text = token.image;}
	)?
	{return text;}
}

/**
 * Options for the whole diagram
 */
void Options(SequenceDiagramBuilder diagram) :
{
	boolean overrideIds;
}
{
	< DIAGRAM_OPTION_OVERRIDE_ID > overrideIds = booleanConstant()
	{
		diagram.setOverrideDefaultIds(overrideIds);
	}
	| < DIAGRAM_OPTION_AUTO_TICK > autoTick = booleanConstant()
}

/**
 * Defines all Lifelines
 */
void LifelineDefinitions(SequenceDiagramBuilder diagram) :
{}
{
	< LIFELINE_DEFINITIONS > LifelineDef(diagram) (< LIFELINE_DEF_DELIMITER > LifelineDef(diagram))* < LL_DEF_NEW_LINE >
}

/**
 * Defines one Lifeline, the id can't be LIFELINE_ACTOR, LIFELINE_ACTIVE
 * or LIFELINE_CREATED_LATER because these are keywords.
 */
void LifelineDef(SequenceDiagramBuilder diagram) :
{
	String name = "";
	String id = null;
	boolean createdOnStart = true;
	Lifeline.LifelineHeadType headType = Lifeline.LifelineHeadType.STANDARD;
}
{
	name = LifelineDefTitleText() (id=LifelineId())?
	(
		< LIFELINE_ACTOR > { headType = Lifeline.LifelineHeadType.ACTOR; }
		| < LIFELINE_ACTIVE > { headType = Lifeline.LifelineHeadType.ACTIVE_CLASS; }
		| < LIFELINE_CREATED_LATER > { createdOnStart = false; }
	) *
	{
		if("lost".equals(id) || "found".equals(id)) {
			throw new SequenceDiagramException("'lost' and 'found' are keywords and can not be used as lifeline identifiers.");		}
		diagram.addLiveline(name, id, headType, createdOnStart);
	}
}

/** can could be multiple lines */
String LifelineDefTitleText() :
{}
{
	< LIFELINE_TITLE >
	{
		/* remove trailing ~, convert new lines to unix style and handle the escaping of \, | and ~ */
		return token.image.substring(0, token.image.length() - 1).replace("\r\n", "\n").replace("\r", "\n").replace("\\~", "~").replace("\\|", "|").replace("\\\\", "\\");
	}
}

/**
 * Can't be one of the following, because these are keywords in the lifeline definition!
 * < LIFELINE_ACTOR: "ACTOR" >
 * < LIFELINE_ACTIVE: "ACTIVE" >
 * < LIFELINE_CREATED_LATER :"CREATED_LATER" >
 */
String LifelineId() :
{}
{
	< LIFELINE_ID >
	{
		return token.image;
	}
}

void Sequence(SequenceDiagramBuilder diagram) :
{}
{
	(
		SequenceTick(diagram) < SEQ_NEW_LINE >
		| (
			SequenceElement(diagram)
			( LOOKAHEAD(2) < COMMAND_DELIMITER > SequenceElement(diagram))*
			(< COMMAND_DELIMITER >)?
			< SEQ_NEW_LINE >
			{ if(autoTick) { diagram.tick(); } }
		)
		| CombinedFragment(diagram)
		| < SEQ_NEW_LINE >
	)*
}

void SequenceTick(SequenceDiagramBuilder diagram) :
{
	int tickCount = 1;
}
{
	< TICK > (tickCount = unsignedIntConstant())?
	{ diagram.tick(tickCount); }
}

void SequenceElement(SequenceDiagramBuilder diagram) :
{}
{
	(
		Message(diagram)
		| Coregion(diagram)
		| ExecutionSpecification(diagram)
		| StateInvariant(diagram)
		//| (diagram) //general ordering
		| InteractionUse(diagram)
		| Continuation(diagram)
	)
}

void CombinedFragment(SequenceDiagramBuilder diagram) :
{
	LifelineInterval interval;
	String operator = "";
}
{
	< COMBINED_FRAGMENT >
	interval = LifelineInterval()
	(
		operator = textUntilNewLine()
		(< COMMAND_DELIMITER >)?
	)?
	(< SEQ_NEW_LINE >)*
	{ diagram.beginCombinedFragment(interval.startId, interval.endId, operator); }
	(Operand(diagram)) +
	{ diagram.endCombinedFragment(); }}

void Operand(SequenceDiagramBuilder diagram) :
{
	InteractionConstraint constraint = null;
}
{
	(		< OPEN_CURLY_BRACKET >
		(< SEQ_NEW_LINE >)* /* TODO check if correct or WARNING true, should always take this choice and consume all new lines */
		(constraint = InteractionConstraint())?
	)
	{
		if(constraint == null) {			diagram.beginOperand();
		} else {			diagram.beginOperand(constraint.text, constraint.lifelineId);
		}
	}
	Sequence(diagram)
	< CLOSE_CURLY_BRACKET >
	{ diagram.endOperand(); }}

InteractionConstraint InteractionConstraint():
{
	InteractionConstraint data = new InteractionConstraint();}
{
	< INTERACTION_CONSTRAINT >
	( data.lifelineId = LifelineId())?
	data.text = textUntilNewLine()
	(< COMMAND_DELIMITER > | < SEQ_NEW_LINE >)
	{
		return data;	}}	

void Message(SequenceDiagramBuilder diagram) :
{
	String leftLifelineId = null;
	String rightLifelineId = null;
	MessageArrowInfo messageArrowInfo;
	String msgText = "";
	int lostCount = 0;
	int foundCount = 0;
}
{
	(
		(
			leftLifelineId = LifelineId()
			| < LOST > { leftLifelineId = "lost"; lostCount++; }
			| < FOUND > { leftLifelineId = "found"; foundCount++; }
		)
		messageArrowInfo =  MessageArrow()
		(
			rightLifelineId = LifelineId()
			| < LOST > { rightLifelineId = "lost"; lostCount++; }
			| < FOUND > { rightLifelineId = "found"; foundCount++; }
		)
		(msgText = textUntilNewLine())?
	)
	{
		if(lostCount + foundCount > 1) {
			// TODO linenumber
			throw new SequenceDiagramException("Error: 'lost' and 'found' can only occur once per message.");
		}
		String send;
		String receive;
		if(messageArrowInfo.fromLeftToRight) {
			send = leftLifelineId;
			receive = rightLifelineId;
		}
		else {
			send = rightLifelineId;
			receive = leftLifelineId;
		}
		if(send.equals("lost")) {
			throw new SequenceDiagramException("Error: 'lost' can only be on the receiving end of a message.");
		}
		else if(send.equals("found")) {
			if(messageArrowInfo.duration != 0) {
				throw new SequenceDiagramException("Error: 'lost' and 'found' messages can only have a duration of 0, but the duration was " + messageArrowInfo.duration + ".");			}
			diagram.addFoundMessage(receive, msgText, messageArrowInfo.lineType, messageArrowInfo.arrowType);
		}
		else
		{
			if(receive.equals("lost")) {
				if(messageArrowInfo.duration != 0) {
					throw new SequenceDiagramException("Error: 'lost' and 'found' messages can only have a duration of 0, but the duration was " + messageArrowInfo.duration + ".");
				}
				diagram.addLostMessage(send, msgText, messageArrowInfo.lineType, messageArrowInfo.arrowType);
			}
			else if(receive.equals("found")) {
				throw new SequenceDiagramException("Error: 'found' can only be on the sending end of a message.");
			}
			else {
				diagram.addMessage(send, receive, messageArrowInfo.duration, msgText, messageArrowInfo.lineType, messageArrowInfo.arrowType);
			}
		}
	}
}

MessageArrowInfo MessageArrow():
{
	MessageArrowInfo messageArrowInfo = new MessageArrowInfo();
}
{
		(
			(	
				/* optional duration seperated with a '-' */
				(
	  				LOOKAHEAD(2)
					< MESSAGE_SOLID_LINE > messageArrowInfo.duration = unsignedIntConstant()
				)?
				messageArrowInfo.lineType = MessageArrowLineType()
				(
					< MESSAGE_ARROW_RIGHT_OPEN > { messageArrowInfo.arrowType = ArrowType.OPEN; }
					| < MESSAGE_ARROW_RIGHT_FILLED >  { messageArrowInfo.arrowType = ArrowType.FILLED; }
				)
			)
			{
				messageArrowInfo.fromLeftToRight = true;
			}
			| (
				(
					< MESSAGE_ARROW_LEFT_OPEN > { messageArrowInfo.arrowType = ArrowType.OPEN; }
					| < MESSAGE_ARROW_LEFT_FILLED >  { messageArrowInfo.arrowType = ArrowType.FILLED; }
				)
				messageArrowInfo.lineType = MessageArrowLineType()
				/* optional duration */
				(
					"-" messageArrowInfo.duration = unsignedIntConstant()
				)?
			)
			{
				messageArrowInfo.fromLeftToRight = false;
			}
		)
		{ return messageArrowInfo; }
}

LineType MessageArrowLineType() :
{
	LineType lineType;
}
{
	(
		< MESSAGE_SOLID_LINE > { lineType = LineType.SOLID; }
		| < MESSAGE_DASHED_LINE >  { lineType = LineType.DASHED; }
	)
	{
		return lineType;
	}
}

void Coregion(SequenceDiagramBuilder diagram) :
{
	String lifelineId;
	boolean start;
}
{
	(
		< START_COREGION > { start = true; }
		| < END_COREGION > { start = false; }
	)
	lifelineId = LifelineId()
	{
		diagram.addCoregion(lifelineId, start);
	}
}

void ExecutionSpecification(SequenceDiagramBuilder diagram) :
{
	String lifelineId;
	boolean on;
}
{
	(
		< EXEC_SPEC_START > { on = true; }
		| < EXEC_SPEC_END > { on = false; }
	)
	lifelineId = LifelineId()
	{
		diagram.changeExecutionSpecification(lifelineId, on);
	}
	( (< LIST_DELIMITER >)? lifelineId = LifelineId()
		{
			diagram.changeExecutionSpecification(lifelineId, on);
		}
	)*
}

void StateInvariant(SequenceDiagramBuilder diagram) :
{
	String lifelineId;
	String text = "";
	boolean stateStyle;
}
{
	(
		< INVARIANT > { stateStyle = false; }
		| < STATE_INVARIANT > { stateStyle = true; }
	) 
	lifelineId = LifelineId()
	(text = textUntilNewLine())?
	{
		diagram.addStateInvariant(lifelineId, text, stateStyle);
	}
}

String textUntilNewLine() :
{
}
{
	< TEXT_DELIMITER >
	< TEXT_UNTIL_NEXT_COMMAND >
	{
		return token.image.replace("\\;", ";").replace("\\\\", "\\");
	}
}

void InteractionUse(SequenceDiagramBuilder diagram):
{
	LifelineInterval interval;
	String text = "";}
{
	(		< REF >
		interval = LifelineInterval()
		(text = textUntilNewLine())?
	)	{
		diagram.addInteractionUse(interval.startId, interval.endId, text);
	}}

void Continuation(SequenceDiagramBuilder diagram):
{
	LifelineInterval interval;
	String text = "";
}
{
	(
		< CONTINUATION >
		interval = LifelineInterval()
		(text = textUntilNewLine())?
	)
	{
		diagram.addContinuation(interval.startId, interval.endId, text);
	}
}

/**
 * @return the start and end of the interval.
 */
LifelineInterval LifelineInterval():
{
	LifelineInterval interval = new LifelineInterval();}
{	interval.startId = LifelineId()
	(< LIST_DELIMITER >)?
	interval.endId = LifelineId()
	{		return interval;	}
}

boolean booleanConstant() :
{ boolean value;}
{
	(
		<FALSE>  { value = false;}
		| <TRUE> { value = true;}
	) {return value; }
}


// Start of the arithmetical interpreter

double doubleTerm() :
{ double v1, v2;}
{
	v1 = doubleProduct()
	(
		"+" v2 = doubleProduct() { v1 = v1 + v2; }
		| "-" v2 = doubleProduct() { v1 = v1 - v2; }
	)*
	{ return v1; }
}

double doubleProduct() :
{ double v1, v2; }
{
	v1 = doubleValue()
	(
		"*" v2 = doubleValue() { v1 = v1 * v2; }
		| "/" v2 = doubleValue() { v1 = v1 / v2; }
	)*
	{ return v1; }
}

double doubleValue() :
{ double value;}
{ 
	(
		"-" value = unsignedDoubleConstant() {value = - value;}
		| value = unsignedDoubleConstant()
		| "(" value = doubleTerm() ")"
	)
	{return value;}
}

double unsignedDoubleConstant() :
{}
{
	(
		<UNSIGNED_INT_CONSTANT>
		| <UNSIGNED_DOUBLE_CONSTANT>
	)
	{
		double value;
		try {
			value = Double.parseDouble(token.image);
		} catch(NumberFormatException e) {
			// only valid double values are accepted from the parser, therefore a NumberFormatException should never occur
			// a double can't be to big, but may loose some precision
			log.fatal("Fatal Error: The string '" + token.image + "' couldn't be parsed as double, but the grammar should ensure that the string is parsable.",e);
			throw (ParseException) new ParseException("Fatal Error: The string '" + token.image + "' couldn't be parsed as double, but the grammar should ensure that the string is parsable.").initCause(e);
		}
		return value;
	}
}

int unsignedIntConstant() :
{}
{
	<UNSIGNED_INT_CONSTANT> {
		int value;
		try {
			value = Integer.parseInt(token.image);
		} catch(NumberFormatException e) {
			// only digits are accepted by the gramer, so the only reason for a NumberFormatException should be that the number is too big for int
			throw (ParseException) new ParseException("Error: The string '" + token.image + "' couldn't be parsed as integer. The most probable reason is that the number is too big.").initCause(e);
		}
		return value;
	}
}