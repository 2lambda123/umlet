options {
  static              = false;
  IGNORE_CASE         = false;
  JAVA_UNICODE_ESCAPE = true;
  JDK_VERSION        = "1.6";
  // Not yet detected as a valid option by the Eclipse plugin, but works nonetheless. This is essential for GWT compatible generated code.
  JAVA_TEMPLATE_TYPE = "modern";  
}


PARSER_BEGIN(SequenceAllInOneParser)
package com.baselet.element.facet.specific.sequence_aio.gen;

public class SequenceAllInOneParser {
}
PARSER_END(SequenceAllInOneParser)

// defines input to be ignored
SKIP:
{ 
	<"//"(~["\n","\r"])*("\n"|"\r"|"\r\n")>
}

TOKEN :
{
	< UNSIGNED_DOUBLE_CONSTANT: ( <DIGIT> ) + ( "." (<DIGIT>)+ )? >
	| < #DIGIT: ["0" - "9"] >
	| < TRUE: "true" >
	| < FALSE: "false" >
	| < SEPARATOR: "%%" >
	| < TITLE_END_DELIMITER: "--" >
	| < NEW_LINE_UNIX: "\n" >
	| < NEW_LINE_WIN: "\r\n" >
	| < NEW_LINE_OSX: "\r" >
}

// general Tokens
TOKEN :
{
	<LAST_LINE_COMMENT: "//"(~["\n","\r"])*>
}

//more general Tokens with no case distinction
TOKEN [IGNORE_CASE] :
{
	< #HEX: ["0" - "9","a"-"f"] >
	| <  SIMPLE_STRING : "\""
   ( 
	   ( ~["\"","\\","\n","\r"]) // everything except the specified chars
	   | ("\\" ["\\","\""])
   )*
   "\"" >
}

/**
 * The main function which parses the whole diagram.
 * Line comments are skipped (see Tokens)
 */
void start() :
{
	String titleText;
	SequenceDiagramNode diagram = new SequenceDiagramNode();
}
{
	(
		(titleText=Title() (Options(diagram) (<TZ> ObjectDefs() (<TZ> MLText() <TZ> Sequence())?)?)?)
		| (titleText=MLText())
	)	{		diagram.setTitle(titleText);
	}
	(< LAST_LINE_COMMENT >)?
	<EOF>	{		return diagram;
	}
}

String Title() :
{String text;}
{
	text = MLText()
	<TITLE_END_DELIMITER>
	{return text;}
}

/**
 * Options for the whole diagram
 */
void Options(SequenceDiagramNode diagram) :
{}{}

/**
 * Defines all Lifelines
 */
void ObjectDefs(SequenceDiagramNode diagram) :
{}
{
	ObjectDef(diagram)+
}

/**
 * Defines all Lifelines
 */
void ObjectDef(SequenceDiagramNode diagram) :
{
	String name;
	boolean createdOnStart = true;
	
}
{
	Text()
	[ObjectDefActor() | ObjectDefActive()]
	ObjectDefCreatedLater()? 
	NewLine()	{
			}
}

String MLText() :
{}
{
}

void NewLine() :{}{	< NEW_LINE_UNIX >
	| < NEW_LINE_WIN >
	| < NEW_LINE_OSX >}

String simpleString() :
{}
{
	<SIMPLE_STRING> { return token.image.substring(1,token.image.length()-1).replace("\\\"", "\"").replace("\\\\", "\\");} //remove the leading and trailing quotes, replace all escaped quotes \" with a normal quote " and replace all \\ with \
}

boolean booleanConstant() :
{ boolean value;}
{
	(
		<FALSE>  { value = false;}
		| <TRUE> { value = true;}
	) {return value; }
}


// Start of the arithmetical interpreter

double doubleTerm() :
{ double v1, v2;}
{
	v1 = doubleProduct()
	(
		"+" v2 = doubleProduct() { v1 = v1 + v2; }
		| "-" v2 = doubleProduct() { v1 = v1 - v2; }
	)*
	{ return v1; }
}

double doubleProduct() :
{ double v1, v2; }
{
	v1 = doubleValue()
	(
		"*" v2 = doubleValue() { v1 = v1 * v2; }
		| "/" v2 = doubleValue() { v1 = v1 / v2; }
	)*
	{ return v1; }
}

double doubleValue() :
{ double value;}
{ 
	(
		"-" value = unsignedDoubleConstant() {value = - value;}
		| value = unsignedDoubleConstant()
		| "(" value = doubleTerm() ")"
	)
	{return value;}
}

double unsignedDoubleConstant() :
{}
{
	<UNSIGNED_DOUBLE_CONSTANT> {
		double value;
		try {
			value = Double.parseDouble(token.image);
		} catch(NumberFormatException e) {
			// TODO log fatal error, only valid double values are accepted from the parser
			// a double can't be to big, but may loose some precision
			throw (ParseException) new ParseException("Fatal Error: The string '" + token.image + "' couldn't be parsed as double, but the grammar should ensure that the string is parsable.").initCause(e);
		}
		return value;
	}
}